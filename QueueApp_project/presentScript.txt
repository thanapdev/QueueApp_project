# บทพูดนำเสนอโครงงาน: QueueApp (ระบบจองคิวและบริการพื้นที่การเรียนรู้)
## สำหรับนำเสนออาจารย์ (ฉบับละเอียด)

---

### 1. บทนำ (Introduction)
"สวัสดีครับ/ค่ะ อาจารย์และเพื่อนๆ วันนี้กลุ่มของพวกเราจะมานำเสนอโครงงานแอปพลิเคชัน **'QueueApp'** ซึ่งเป็นแพลตฟอร์มบริหารจัดการพื้นที่การเรียนรู้และระบบคิวอัจฉริยะภายในมหาวิทยาลัยครับ/ค่ะ"

**ที่มาและความสำคัญ:**
"ปัจจุบันนิสิตมักประสบปัญหาในการเข้าใช้บริการพื้นที่ส่วนกลาง เช่น ห้อง Co-working Space, ห้องดูหนัง หรือโต๊ะบอร์ดเกม ที่มักจะเต็มหรือต้องเดินมาเช็คสถานะด้วยตัวเอง ทำให้เสียเวลา นอกจากนี้การติดตามข่าวสารกิจกรรมหรือการต่อคิวเข้าร่วมงานต่างๆ ยังขาดความสะดวก เราจึงพัฒนาแอปพลิเคชันนี้ขึ้นมาเพื่อแก้ปัญหาเหล่านี้แบบครบวงจรครับ/ค่ะ"

---

### 2. ภาพรวมสถาปัตยกรรมระบบ (System Architecture)
"ในส่วนของเทคนิค เราพัฒนาแอปพลิเคชันนี้ด้วยภาษา **Swift** โดยใช้เฟรมเวิร์ก **SwiftUI 100%** สำหรับการสร้าง User Interface ที่ทันสมัยและลื่นไหลครับ/ค่ะ"

"สถาปัตยกรรมที่เราเลือกใช้คือ **MVVM (Model-View-ViewModel)** ซึ่งช่วยแยกส่วนการแสดงผล (View) ออกจากตรรกะการทำงาน (Logic) ทำให้โค้ดเป็นระเบียบและดูแลรักษาง่าย"

"สำหรับ Backend เราเลือกใช้ **Firebase** เต็มรูปแบบ ซึ่งเป็นหัวใจสำคัญที่ทำให้แอปเราทำงานแบบ Real-time ได้ครับ โดยเราใช้บริการหลัก 2 ตัว คือ:

1.  **Firebase Authentication**:
    -   ใช้จัดการระบบสมาชิกและความปลอดภัยครับ
    -   ระบบนี้ช่วยให้เราแยก Role ระหว่าง 'Student' และ 'Admin' ได้อย่างชัดเจน ทำให้สามารถจำกัดสิทธิ์การเข้าถึงฟีเจอร์หลังบ้านได้อย่างปลอดภัย

2.  **Cloud Firestore**:
    -   เป็นฐานข้อมูลแบบ NoSQL ที่มีความเร็วสูงและยืดหยุ่นครับ
    -   **จุดเด่นที่เป็น Killer Feature** ของโปรเจคนี้คือระบบ **Real-time Listeners** (Snapshot Listeners) ครับ
    -   *อธิบายให้เห็นภาพนะครับ:* ในระบบจองพื้นที่ ทันทีที่มีนิสิตคนหนึ่งกดจองโต๊ะบอร์ดเกม ข้อมูลจะถูกบันทึกลง Firestore และระบบจะส่งสัญญาณแจ้งเตือนไปยังแอปของนิสิตทุกคนที่เปิดหน้านั้นอยู่ ให้เปลี่ยนสถานะโต๊ะนั้นเป็น 'สีเทา' (ไม่ว่าง) ทันทีภายในเสี้ยววินาที โดยที่ผู้ใช้ไม่ต้องกด Refresh หน้าจอเลยครับ
    -   เทคนิคนี้เรานำมาใช้กับทั้งระบบจอง, ระบบคิว, และแชทใน Social Board ทำให้ User Experience ลื่นไหลมากครับ"

---

### 3. ฟีเจอร์หลักของผู้ใช้งาน (User Features)
"ขออนุญาตพาชมฟีเจอร์หลักในมุมมองของผู้ใช้งาน (Student/Guest) นะครับ/คะ"

**3.1 ระบบยืนยันตัวตน (Authentication)**
"เริ่มต้นที่หน้า Login เรามีการแบ่งระดับผู้ใช้งานเป็น 3 ระดับ คือ Guest, Student และ Admin
-   **Student:** สามารถ Login เพื่อเข้าถึงฟีเจอร์จองและ Social ได้ครบถ้วน
-   **Guest:** สามารถเข้ามาดูข้อมูลกิจกรรมและแผนที่ได้ แต่จะจองไม่ได้ครับ/ค่ะ"

**3.2 หน้าหลัก (Service Dashboard)**
"เมื่อเข้ามาจะพบกับหน้า Service View ที่รวบรวมบริการทั้งหมดไว้ในที่เดียว ดีไซน์เน้นความสวยงามและใช้งานง่าย ประกอบด้วย 4 หมวดหมู่หลักครับ"

**3.3 ระบบจองพื้นที่ (Booking System) *ไฮไลท์สำคัญ***
"นี่คือหัวใจหลักของแอปเราครับ ระบบจองพื้นที่รองรับ 4 บริการ:
1.  **Board Game:** จองโต๊ะและเลือกเกมที่อยากเล่นได้ (เลือกได้สูงสุด 3 เกม)
2.  **Co-Working Space:** เลือกที่นั่งแบบระบุตำแหน่งได้เลย (Seat Selection)
3.  **Green Screen Studio:** จองห้องถ่ายทำพร้อมเลือกอุปกรณ์เสริม เช่น กล้อง หรือไฟ
4.  **Netflix Room:** จองห้องดูหนังส่วนตัวตามรอบเวลา

จุดเด่นคือระบบ **Real-time** ครับ ถ้ามีคนอื่นจองตัดหน้า สถานะในหน้าจอเราจะเปลี่ยนเป็นสีเทา (ไม่ว่าง) ทันที และเรายังมีระบบป้องกันการจองซ้อน (Double Booking Prevention) ด้วยครับ"

**3.4 ระบบคิวและกิจกรรม (Queue & Activities)**
"นิสิตสามารถดูรายการกิจกรรมที่เกิดขึ้นในมหาลัย และกดเข้าร่วมคิว (Join Queue) ผ่านแอปได้ทันที โดยจะเห็นจำนวนคิวที่รออยู่แบบ Real-time ลดความแออัดหน้างานครับ"

**3.5 สังคมออนไลน์ (Social Board)**
"ฟีเจอร์ SWU Social เป็นพื้นที่ให้นิสิตมาพูดคุย แลกเปลี่ยน หรือสอบถามข้อมูลกันได้ รองรับการโพสต์แบบระบุตัวตนและแบบไม่ระบุตัวตน (Anonymous) มีระบบกด Like และ Comment เพื่อสร้าง Community ภายในครับ"

**3.6 แผนที่ (Campus Map)**
"สุดท้ายคือแผนที่แสดงจุดสำคัญต่างๆ ในมหาลัย ช่วยให้นิสิตใหม่หรือบุคคลภายนอกเดินทางได้สะดวกขึ้นครับ"

---

### 4. ส่วนของผู้ดูแลระบบ (Admin Dashboard)
"นอกจากฝั่งผู้ใช้แล้ว เรายังมีระบบหลังบ้านสำหรับ Admin ที่ทรงพลังครับ"
"Admin สามารถ:
-   ดูภาพรวมสถิติการใช้งาน (Dashboard)
-   จัดการ Booking: ดูรายการจองทั้งหมด และยกเลิกการจองที่ผิดปกติได้
-   จัดการ Queue: สร้างกิจกรรมใหม่, เรียกคิว, หรือปิดรับคิว
-   ดูแล Social: ลบโพสต์ที่ไม่เหมาะสมได้ทันที"

---

### 5. ความท้าทายและสิ่งที่ได้เรียนรู้ (Challenges & Learning)
"ความท้าทายหลักในการทำโปรเจคนี้คือการจัดการ State ของแอปพลิเคชันที่ซับซ้อนครับ เพราะเราต้องซิงค์ข้อมูล Real-time จาก Firebase ตลอดเวลา เราจึงสร้างคลาส **'AppState'** ขึ้นมาเป็นตัวกลางจัดการข้อมูลทั้งหมด (Global State Management) ทำให้แอปทำงานเสถียรและข้อมูลไม่ขัดแย้งกันครับ"

---

### ### 7. ช่วงถาม-ตอบ (Q&A) - รวมคำถามปราบเซียน (Deep Technical Questions)

**หมวด 1: Architecture & Design (สถาปัตยกรรมและโครงสร้าง)**

**Q1: "โปรเจคนี้เป็น Design-time หรือ Run-time?"**
**A:** "เป็นแบบ **Hybrid (ผสมผสาน)** ครับ"
*   **Design-time:** ส่วนของ User Interface (UI), Business Logic, และรายการบริการหลัก (Service Catalog) ถูกกำหนดไว้ตายตัวในโค้ด (Hardcoded) เพื่อความเสถียรและประสิทธิภาพครับ
*   **Run-time:** ส่วนของ Data และ State ทั้งหมด เช่น สถานะการจอง, จำนวนคิว, และข้อมูลผู้ใช้ เป็น Run-time 100% ที่เปลี่ยนแปลงตลอดเวลาตามข้อมูลจริงจาก Firebase ครับ

**Q2: "ทำไมถึงเลือกใช้ MVVM? ดีกว่า MVC ตรงไหนในบริบทของ SwiftUI?"**
**A:** "เพราะ **SwiftUI ถูกออกแบบมาให้ทำงานแบบ Data-driven** ซึ่งเข้ากับ Concept ของ MVVM (Model-View-ViewModel) มากที่สุดครับ"
*   **MVC (Model-View-Controller):** Controller ต้องคอยสั่ง View ให้ update (Imperative) ซึ่งยุ่งยากใน SwiftUI
*   **MVVM:** View จะผูก (Bind) กับ ViewModel โดยตรง เมื่อข้อมูลใน ViewModel เปลี่ยน View จะอัปเดตตัวเองอัตโนมัติ (Reactive) ทำให้โค้ดสะอาดและจัดการ State ได้ง่ายกว่ามากครับ

**Q3: "ทำไมถึงใช้ Global State (AppState) ไม่กลัว Memory Leak หรือ?"**
**A:** "เราใช้ `AppState` เป็น **Single Source of Truth** เพียงจุดเดียวเพื่อให้ข้อมูลตรงกันทั้งแอปครับ"
*   "สำหรับการจัดการ Memory เราใช้ `@StateObject` ที่ Root และส่งต่อแบบ `.environmentObject` ซึ่ง SwiftUI จะจัดการ Lifecycle ให้เอง"
*   "ส่วน Listener ของ Firebase เรามีการประกาศ `deinit` หรือฟังก์ชัน `removeListener` เพื่อยกเลิกการเชื่อมต่อเมื่อ User Logout หรือปิดหน้าจอ เพื่อป้องกัน Memory Leak ครับ"

---

**หมวด 2: Database & Backend (ฐานข้อมูล)**

**Q4: "ทำไมเลือก NoSQL (Firestore) แทนที่จะใช้ SQL (MySQL/PostgreSQL)?"**
**A:** "เหตุผลหลักคือ **Speed** และ **Real-time Capabilities** ครับ"
*   "ระบบจองคิวต้องการความเร็วในการตอบสนองสูงมาก (Low Latency) ซึ่ง Firestore ตอบโจทย์เรื่องนี้ได้ดีกว่า"
*   "โครงสร้างข้อมูลเราไม่ได้มีความซับซ้อนแบบ Relational มากนัก (เช่น ไม่มีการ Join ตารางเยอะๆ) การเก็บแบบ Document จึงยืดหยุ่นและดึงข้อมูลได้เร็วกว่าครับ"

**Q5: "ถ้ามีคนใช้งานพร้อมกัน 1,000 คน ระบบจะล่มไหม? (Scalability)"**
**A:** "ในฝั่ง Server (Firebase) **ไม่ล่มแน่นอนครับ** เพราะเป็น Serverless ที่ Scale อัตโนมัติตามจำนวน Request"
*   "แต่สิ่งที่ต้องระวังคือ **Client-side Performance** ครับ ถ้าข้อมูลเยอะเกินไป เครื่องอาจจะหน่วง เราจึงแก้ปัญหาด้วยการใช้ `Query` ที่เจาะจง (เช่น `.whereField("status", isEqualTo: "active")`) เพื่อดึงเฉพาะข้อมูลที่จำเป็นมาแสดงผล ไม่ดึงมาทั้งหมดครับ"

---

**หมวด 3: Concurrency & Logic (การทำงานพร้อมกัน)**

**Q6: "ป้องกันปัญหาจองซ้อน (Double Booking) หรือ Race Condition อย่างไร? (เช่น กดจองวินาทีเดียวกัน)"**
**A:** "ในระดับ Production เราจะใช้ **Firebase Transactions** ครับ"
*   "คือการสั่งให้ Database เช็คสถานะล่าสุดก่อนเขียนข้อมูล ถ้ามีคนอื่นเขียนตัดหน้าไปแล้ว Transaction จะ Fail และเราจะแจ้งเตือน User ว่า 'จองไม่ทัน'"
*   "แต่ในเวอร์ชันปัจจุบัน เราใช้เทคนิค **Optimistic UI + Real-time Listener** ครับ คือทันทีที่มีคนจอง Listener จะอัปเดตหน้าจอของทุกคนให้เป็นสีเทาทันที ทำให้โอกาสที่จะกดซ้อนกันมีน้อยมากครับ"

**Q7: "จัดการเรื่องเวลา (Time Synchronization) อย่างไร? ถ้า User แก้เวลาในเครื่องตัวเอง ระบบจะรวนไหม?"**
**A:** "ไม่รวนครับ เพราะเรายึด **Server Timestamp** เป็นหลัก"
*   "ตอนบันทึกข้อมูลลง Database เราใช้ `FieldValue.serverTimestamp()` ของ Firebase
*   "ส่วนการนับถอยหลัง (Timer) เราคำนวณจาก `endTime` ที่มาจาก Server เทียบกับเวลาปัจจุบัน ทำให้ต่อให้ User แก้เวลาเครื่อง ก็ไม่มีผลต่อเวลาหมดอายุจริงในระบบครับ"

---

---

**หมวด 4: Security (ความปลอดภัย)**

**Q8: "ถ้าเด็กหัวหมอ ยิง API ตรงๆ เพื่อเปลี่ยนสถานะตัวเองเป็น Admin ทำได้ไหม?"**
**A:** "ทำไม่ได้ครับ เพราะเรามี **Firebase Security Rules** กำกับอยู่ฝั่ง Server"
*   "เราเขียนกฎไว้ว่า การจะเขียนข้อมูลลง Field `role` หรือ `status` ได้ ต้องผ่านเงื่อนไขที่กำหนดเท่านั้น เช่น User ทั่วไปจะแก้ได้แค่การจองของตัวเอง แต่จะไปแก้ข้อมูลคนอื่นหรือเปลี่ยน Role ตัวเองไม่ได้ครับ"

---

**หมวด 5: เจาะลึกโค้ดและฟังก์ชันสำคัญ (Code & Methods Deep Dive)**

**Q9: "ใน `AppState` ฟังก์ชัน `listenForActiveBooking` ทำงานยังไง? ทำไมต้องใช้ `addSnapshotListener`?"**
*   **Code Logic:** "ฟังก์ชันนี้จะสร้าง Connection ค้างไว้กับ Firestore ที่ Collection 'bookings' โดย Filter เฉพาะ `userID` ของเราและสถานะที่ยังไม่จบครับ"
*   **Why:** "เราใช้ `addSnapshotListener` แทนการ `getDocuments` ปกติ เพราะต้องการให้แอป **Reactive** ครับ คือถ้า Admin กด Check-in ปุ๊บ หรือหมดเวลาปุ๊บ โค้ดใน Block นี้จะทำงานทันทีและอัปเดตหน้าจอ User โดยอัตโนมัติครับ"
*   **Alternatives:** "ถ้าไม่ใช้ Listener ก็ต้องเขียนระบบ **Polling** (ตั้ง Timer ให้ยิง API เช็คทุก 5 วิ) ซึ่งจะทำให้แอปช้าและเปลืองเน็ตกว่ามากครับ"

**Q10: "ใน `startTimer` ทำไมต้องเช็ค `booking.status == 'In-Use'` ก่อนเริ่มนับเวลา?"**
*   **Code Logic:** "ในโค้ดผมเขียนเงื่อนไขดักไว้ครับ ถ้าสถานะเป็นแค่ 'Booked' หรือ 'Queued' ผมจะยังไม่สั่ง `Timer.publish` ครับ"
*   **Why:** "เพื่อความยุติธรรมครับ เราจะเริ่มนับเวลา 2 ชั่วโมงก็ต่อเมื่อ User ไปถึงหน้างานและ Admin กด Check-in เปลี่ยนสถานะเป็น 'In-Use' แล้วเท่านั้นครับ ถ้า User มาช้า เวลาจองก็ยังไม่เดินครับ"
*   **Alternatives:** "ถ้าไม่เช็คตรงนี้ เวลาก็จะเดินตั้งแต่กดจองที่บ้าน ซึ่งอาจจะทำให้ User เสียสิทธิ์การใช้งานจริงครับ"

**Q11: "ใน `SocialViewModel` ตอนกดไลค์ (`toggleLike`) ทำไมใช้ `FieldValue.arrayUnion`? ทำไมไม่ดึงค่าเก่ามาบวก 1?"**
*   **Code Logic:** "ผมใช้คำสั่งพิเศษของ Firestore คือ `arrayUnion` (สำหรับเพิ่ม ID) และ `increment` (สำหรับเพิ่มตัวเลข) ส่งไปที่ Server โดยตรงครับ"
*   **Why:** "เพื่อป้องกัน **Race Condition** ครับ ถ้ามีคนกดไลค์พร้อมกัน 100 คน แล้วเราใช้วิธี 'ดึงค่าเก่ามาบวก' คะแนนอาจจะหายเพราะมันเซฟทับกันครับ แต่วิธีนี้ Server จะจัดการคิวให้เอง คะแนนเป๊ะแน่นอน"
*   **Alternatives:** "อีกวิธีคือใช้ **Transaction** ครับ ซึ่งปลอดภัยเหมือนกันแต่เขียนโค้ดยากกว่าและช้ากว่านิดหน่อยครับ"

**Q12: "ทำไม `AppState` ต้อง conform `ObservableObject` และตัวแปรข้างในต้องมี `@Published`?"**
*   **Code Logic:** "เป็นกลไกของ SwiftUI ครับ `ObservableObject` คือคลาสที่ปล่อยสัญญาณได้ ส่วน `@Published` คือตัวแปรที่จะส่งสัญญาณเมื่อค่าเปลี่ยน"
*   **Why:** "เพื่อให้ View ที่ถือครอง `AppState` อยู่ (ผ่าน `@EnvironmentObject`) รู้ตัวและ **Re-render หน้าจออัตโนมัติ** ครับ เช่น พอ `isLoggedIn` เปลี่ยนเป็น true หน้าจอก็จะสลับจาก LoginView เป็น ServiceView ทันทีโดยที่เราไม่ต้องเขียนโค้ดสั่งเปลี่ยนหน้าเลยครับ"
*   **Alternatives:** "ถ้าไม่ใช้ท่านี้ ก็ต้องใช้ **Delegate Pattern** หรือ **NotificationCenter** แบบสมัย UIKit ซึ่งต้องเขียนโค้ดสั่ง update UI เองทุกจุด ยุ่งยากกว่ามากครับ"

---

### 8. สรุป (Conclusion)
"สรุปแล้ว QueueApp ไม่ใช่แค่แอปจองคิว แต่เป็น Digital Solution ที่ช่วยยกระดับคุณภาพชีวิตในรั้วมหาวิทยาลัย อำนวยความสะดวกทั้งนิสิตและเจ้าหน้าที่ ลดขั้นตอนที่ยุ่งยาก และสร้างสังคมการแบ่งปันพื้นที่ร่วมกันอย่างมีประสิทธิภาพครับ/ค่ะ"

"ขอบคุณครับ/ค่ะ ยินดีตอบคำถามเพิ่มเติมครับ"

---

## ภาคผนวก: อธิบายหน้าที่ของไฟล์ในโปรเจค (File Descriptions)

### 1. Root & Configuration (ส่วนเริ่มต้นและตั้งค่าระบบ)
*   **QueueApp_projectApp.swift**
    *   **หน้าที่:** เป็นจุดเริ่มต้น (Entry Point) ของแอปพลิเคชัน
    *   **การทำงาน:**
        *   เรียกใช้ `FirebaseApp.configure()` เพื่อเริ่มต้นการเชื่อมต่อกับ Firebase
        *   สร้าง Instance ของ `AppState` (Global Store) และส่งต่อให้ View อื่นๆ ผ่าน `.environmentObject`
        *   กำหนด Root View เป็น `ContentView`

*   **ContentView.swift**
    *   **หน้าที่:** เป็นตัวจัดการ Navigation หลักของแอป (Root Router)
    *   **การทำงาน:**
        *   ตรวจสอบตัวแปร `appState.isLoggedIn` และ `appState.isBrowsingAsGuest`
        *   ถ้า Login แล้ว -> แสดง `ServiceView` (หน้าหลัก)
        *   ถ้ายังไม่ Login -> แสดง `WelcomeView` (หน้าต้อนรับ)
        *   ใช้ `ZStack` และ `if-else` ในการสลับหน้าจอ ทำให้การเปลี่ยนหน้าดูลื่นไหล

*   **Resources/GoogleService-Info.plist**
    *   **หน้าที่:** ไฟล์ Configuration ที่ได้จาก Firebase Console
    *   **รายละเอียด:** เก็บ API Keys, Project ID, และ Bundle ID เพื่อให้แอปสามารถยืนยันตัวตนและเชื่อมต่อกับโปรเจค Firebase ที่ถูกต้องได้

### 2. Models & Logic (โครงสร้างข้อมูลและตรรกะ)
*   **Utils/AppState.swift** **(หัวใจสำคัญของแอป)**
    *   **หน้าที่:** เป็น Global State Manager (Single Source of Truth) จัดการข้อมูลที่ใช้ร่วมกันทั้งแอป
    *   **Key Features:**
        *   `@Published var currentUser`: เก็บข้อมูล User ที่ Login อยู่
        *   `@Published var activeReservation`: เก็บสถานะการจองปัจจุบันของ User (Real-time)
        *   `startTimer()`: ระบบจับเวลานับถอยหลังแบบรวมศูนย์ (Unified Timer) สำหรับการจองทุกประเภท
        *   `listenForActiveBooking()`: ใช้ `SnapshotListener` ของ Firestore เพื่อดักฟังการเปลี่ยนแปลงสถานะการจองแบบ Real-time (เช่น เมื่อ Admin กด Check-in หรือหมดเวลา)

*   **Model/Models.swift**
    *   **หน้าที่:** เก็บ Data Model พื้นฐานของระบบ
    *   **โครงสร้างสำคัญ:**
        *   `struct User`: เก็บข้อมูลผู้ใช้ (Name, StudentID, Role)
        *   `struct Activity`: เก็บข้อมูลกิจกรรม (ชื่อกิจกรรม, จำนวนคิว)
        *   `struct QueueItem`: เก็บข้อมูลบัตรคิวแต่ละใบ

*   **Model/BookingModels.swift**
    *   **หน้าที่:** เก็บ Data Model เฉพาะสำหรับระบบจองพื้นที่
    *   **โครงสร้างสำคัญ:**
        *   `struct Booking`: โมเดลหลักของการจอง รองรับ `Codable` เพื่อแปลงข้อมูลจาก Firestore เก็บเวลาเริ่ม-จบ (Timestamp), สถานะ (Booked, In-Use), และรายการของที่ยืม
        *   `enum LibraryService`: ระบุประเภทบริการ (Board Game, Co-working, etc.) พร้อมสีและไอคอนประจำหมวด

*   **Model/SocialViewModel.swift**
    *   **หน้าที่:** จัดการ Logic ของหน้า Social Board
    *   **การทำงาน:**
        *   `fetchPosts()`: ดึงข้อมูลโพสต์จาก Collection `social_posts` แบบ Real-time
        *   `createPost()`: สร้างโพสต์ใหม่ โดยรองรับโหมด Anonymous (ซ่อนชื่อจริงแต่เก็บใน Database)
        *   `toggleLike()`: จัดการ Logic การกด Like โดยใช้ `FieldValue.arrayUnion` และ `arrayRemove` เพื่อป้องกัน Race Condition

### 3. Views - General (หน้าจอทั่วไป)
*   **View/WelcomeView.swift**
    *   **หน้าที่:** หน้าแรกสุดที่ผู้ใช้เห็น
    *   **การทำงาน:** มีปุ่มเลือกเส้นทาง 2 แบบ คือ "Login" (สำหรับนิสิต/Admin) และ "Guest Mode" (สำหรับบุคคลภายนอก)

*   **View/LoginView.swift**
    *   **หน้าที่:** หน้าเข้าสู่ระบบ
    *   **การทำงาน:**
        *   รับ Student ID และ Password
        *   ตรวจสอบความถูกต้องผ่าน `AppState.loginAsStudent`
        *   มี Logic แยก Role (Student vs Admin) เพื่อพาไปหน้า Dashboard ที่ถูกต้อง

*   **View/ServiceView.swift**
    *   **หน้าที่:** หน้า Dashboard หลัก (Home Screen)
    *   **การทำงาน:**
        *   แสดง Grid เมนูบริการ 4 อย่าง (Booking, Queue, Social, Map)
        *   แสดง Banner ด้านล่างถ้ามีการจองค้างอยู่ (`MyBookingBannerView`)

### 4. Views - Booking System (ระบบจองพื้นที่)
*   **View/Booking/BookingView.swift**
    *   **หน้าที่:** หน้ารวมเมนูบริการจองพื้นที่
    *   **การทำงาน:** แสดงรายการบริการ `libraryServices` เป็น Grid ให้เลือก

*   **View/Booking/BoardGameBookingView.swift**
    *   **หน้าที่:** หน้าจองโต๊ะบอร์ดเกม
    *   **การทำงาน:**
        *   มี UI ให้เลือกเกม (Multi-selection)
        *   มี UI ให้เลือกโต๊ะ (Table Selection)
        *   ตรวจสอบว่าเกมไหนถูกยืมไปแล้วผ่าน `appState.currentBookedGames`

*   **View/Booking/CoWorkingBookingView.swift**
    *   **หน้าที่:** หน้าจอง Co-working Space
    *   **การทำงาน:** แสดงผังที่นั่งจำลอง ให้ผู้ใช้กดเลือกจุดที่ต้องการนั่ง (Seat Selection)

*   **View/Booking/BookingDetailView.swift**
    *   **หน้าที่:** หน้าสรุปรายละเอียดการจอง
    *   **การทำงาน:** แสดง QR Code (จำลอง), เวลานับถอยหลัง, และปุ่ม "Cancel Booking" หรือ "Extend Time" (ต่อเวลา)

### 5. Views - Social Board (สังคมออนไลน์)
*   **View/Social/SocialBoardView.swift**
    *   **หน้าที่:** หน้า Feed แสดงกระทู้พูดคุย
    *   **การทำงาน:** ใช้ `ScrollView` และ `LazyVStack` เพื่อแสดงรายการโพสต์ เรียงตามเวลาล่าสุด

*   **View/Social/CreatePostView.swift**
    *   **หน้าที่:** หน้าเขียนโพสต์ใหม่
    *   **การทำงาน:** มี Toggle "Post Anonymously" เพื่อให้ผู้ใช้เลือกโพสต์แบบไม่ระบุตัวตนได้

### 6. Views - Admin Dashboard (ระบบหลังบ้าน)
*   **View/Admin/AdminDashboardView.swift**
    *   **หน้าที่:** ศูนย์รวมเครื่องมือสำหรับ Admin
    *   **การทำงาน:** แสดงปุ่มลัดไปหน้าจัดการต่างๆ (Booking, Queue, Social)

*   **View/Admin/AdminBookingView.swift**
    *   **หน้าที่:** หน้าจัดการรายการจองทั้งหมด
    *   **การทำงาน:**
        *   แสดงรายการจองที่ Active อยู่ทั้งหมด (Real-time)
        *   มีปุ่ม "Check-in" เพื่อเริ่มนับเวลา
        *   มีปุ่ม "Finish" เพื่อจบการใช้งานและคืนพื้นที่

*   **View/Admin/QueueView.swift**
    *   **หน้าที่:** หน้าจัดการคิวและกิจกรรม
    *   **การทำงาน:** สามารถสร้างกิจกรรมใหม่ (Create Activity) และกดเรียกคิว (Call Queue) ได้

### 7. Utils & Styles (เครื่องมือและดีไซน์)
*   **Style/AppTheme.swift**
    *   **หน้าที่:** Design System ของแอป
    *   **รายละเอียด:** เก็บค่าสี (`Color.Theme`), ฟอนต์, และ Gradient ที่ใช้ซ้ำๆ เพื่อให้ดีไซน์ไปในทิศทางเดียวกัน (Consistency)

*   **Style/AppComponents.swift**
    *   **หน้าที่:** รวม UI Components ที่ใช้บ่อย
    *   **ตัวอย่าง:** `PrimaryButton` (ปุ่มหลัก), `CustomTextField` (ช่องกรอกข้อความ), `CardView` (กรอบเนื้อหา) ช่วยลด Code Duplication ในหน้า View หลัก
